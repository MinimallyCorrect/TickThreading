<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<mods>
	<preSrgCore preSrg="true" onDemand="true">
		<class id="net.minecraftforge.event.Event">
			<final field="listeners"/>
			<removeFieldAndInitializers field="annotationMap" silent="true"/>
			<addAll fromClass="nallar.patched.forge.PatchEvent"/>
		</class>
		<class id="denoflionsx.denLib.Lib.denLib$StringUtils">
			<replaceMethod code="return $1;">Hash(Ljava.lang.String;)Ljava.lang.String;</replaceMethod>
		</class>
	</preSrgCore>
	<coreMods onDemand="true">
		<class id="cpw.mods.fml.common.Loader">
			<addAll fromClass="nallar.patched.forge.PatchLoader"/>
			<replaceMethodCall method="info" index="0" code="{ }">loadMods</replaceMethodCall>
		</class>
		<class id="cpw.mods.fml.common.ModAPIManager">
			<replaceMethodCall method="info" index="0" code="{ }">registerDataTableAndParseAPI</replaceMethodCall>
		</class>
		<class id="cpw.mods.fml.common.LoadController">
			<replaceMethodCall method="log" index="1" code="{ }">buildModList</replaceMethodCall>
		</class>
	</coreMods>
	<theWarOnLogSpam onDemand="true">
		<class id="mcp.mobius.waila.Waila">
			<replaceMethodCall method="printf" code="{ $_ = null; }">loadComplete</replaceMethodCall>
		</class>
		<class id="codechicken.microblock.MicroMaterialRegistry$">
			<replaceMethodCall method="println" index="1" code="{ }">registerMaterial</replaceMethodCall>
		</class>
		<class id="buildcraft.core.Version">
			<disable>check</disable>
		</class>
		<class id="aroma1997.core.version.ThreadVersionChecking">
			<disable>run</disable>
		</class>
		<class id="aroma1997.core.Aroma1997Core">
			<replaceMethodCall method="logServer" code="{ }">preInit,init,postInit,serverStartup,serverStartedUp</replaceMethodCall>
		</class>
		<class id="com.dmillerw.remoteIO.core.handler.PacketHandler">
			<replaceMethodCall method="info" code="{ }">sendConfigData</replaceMethodCall>
		</class>
		<class id="magicbees.world.feature.FeatureHive">
			<replaceFieldUsage field="logSpawns" writeCode="logSpawns = false;">^static^</replaceFieldUsage>
		</class>
		<class id="net.bdew.lib.recipes.gencfg.GenericConfigLoader$class">
			<replaceMethodCall method="info" code="{ }">processConfigStatement</replaceMethodCall>
		</class>
		<class id="codechicken.nei.NEIClientConfig">
			<replaceMethodCall method="println" code="{ }">bootNEI</replaceMethodCall>
		</class>
		<class id="codechicken.nei.NEIServerConfig">
			<replaceMethodCall method="println" code="{ }">loadPlayer,unloadPlayer</replaceMethodCall>
		</class>
		<class id="codechicken.nei.NEISPH">
			<replaceMethodCall method="println" code="{ }">sendHasServerSideTo</replaceMethodCall>
		</class>
		<class id="calclavia.components.CalclaviaLoader">
			<replaceMethodCall method="info" code="{ }">requireItem,requireBlock</replaceMethodCall>
		</class>
		<class id="denoflionsx.denLib.Mod.Handlers.NewDictHandler.DenLibDictionaryHandler">
			<replaceMethodCall method="log" code="{ }">doEvent</replaceMethodCall>
		</class>
		<class id="denoflionsx.denLib.Mod.Handlers.NewFluidHandler.DenLibFluidHandler">
			<replaceMethodCall method="log" code="{ }">onEvent</replaceMethodCall>
		</class>
		<class id="
		mods.natura.plugins.PluginController
		tconstruct.plugins.PluginController
		">
			<replaceMethodCall method="info" code="{ }">^all^</replaceMethodCall>
		</class>
		<class id="Reika.GeoStrata.Guardian.GuardianStoneManager">
			<replaceMethodCall method="log" index="0" code="{ }">save,read</replaceMethodCall>
		</class>
		<class id="Reika.RotaryCraft.Auxiliary.RecipeManagers">
			<replaceMethodCall method="log" code="{ }">addOreRecipes</replaceMethodCall>
		</class>
		<class id="
		Reika.DragonAPI.Base.DragonAPIMod
		Reika.DragonAPI.Base.ModHandlerBase">
			<replaceMethodCall method="pConsole" code="{ }"/>
		</class>
		<class id="Reika.DragonAPI.Libraries.Java.ReikaObfuscationHelper">
			<replaceMethodCall method="pConsole" code="{ }">addField,addMethod</replaceMethodCall>
		</class>
		<class id="Reika.DragonAPI.Base.PlayerTracker">
			<replaceMethodCall method="pConsole" index="0" code="{ }">save,read</replaceMethodCall>
		</class>
		<class id="Reika.DragonAPI.ModList">
			<replaceMethodCall method="pConsole" index="0" code="{ }" silent="true"/>
			<replaceMethodCall method="pConsole" index="1" code="{ }" silent="true"/>
			<replaceMethodCall method="pConsole" index="2" code="{ }" silent="true"/>
		</class>
		<class id="Reika.DragonAPI.Libraries.Java.ReikaJavaLibrary">
			<newField static="" field="logger" class="java.util.logging.Logger" code="none"/>
			<final field="logger"/>
			<addStaticInitializer code="{
				logger = java.util.logging.Logger.getLogger(&quot;Dragon&quot;);
				logger.setParent(java.util.logging.Logger.getLogger(&quot;ForgeModLoader&quot;));
				logger.setUseParentHandlers(true);
			}"/>
			<replaceMethod code="{
				if ($1 == null) {
					logger.info(&quot;null passed to Reika pConsole&quot;);
				} else if ($1 instanceof String || $1 instanceof Integer || $1 instanceof Boolean) {
					logger.info(String.valueOf($1));
				} else {
					logger.info(String.valueOf($1) + &quot; of class &quot; + $1.getClass().getName());
				}
			}">pConsole(Ljava/lang/Object;)V
			</replaceMethod>
		</class>
	</theWarOnLogSpam>
	<minecraftCommon>
		<class id="net.minecraft.logging.LogAgent">
			<insertAfter code="{ nallar.log.PatchLog.coloriseLogger(); }">setupLogger</insertAfter>
		</class>
		<class id="net.minecraft.world.SpawnerAnimals" env="forge">
			<addAll fromClass="nallar.patched.PatchSpawnerAnimalsForge"/>
		</class>
		<class id="net.minecraft.world.SpawnerAnimals" env="mcpc">
			<synchronize>findChunksForSpawning</synchronize>
		</class>
		<class id="net.minecraft.world.SpawnerAnimals">
			<addAll fromClass="nallar.patched.PatchSpawnerAnimals"/>
			<profile>findChunksForSpawning</profile>
		</class>
		<class id="net.minecraft.world.storage.ThreadedFileIOBase">
			<synchronize>queueIO,waitForFinish</synchronize>
		</class>
		<class id="net.minecraft.world.storage.MapInfo">
			<synchronize>^all^</synchronize>
		</class>
		<class id="net.minecraft.pathfinding.Path">
			<newInitializer field="pathPoints" class="net.minecraft.pathfinding.PathPoint" arraySize="128"/>
		</class>
		<class id="net.minecraft.server.MinecraftServer">
			<addAll fromClass="nallar.patched.server.PatchMinecraftServer"/>
			<insertBefore code="{
				if (this.^field:MinecraftServer/serverStopped^) {
					return;
				}
				this.^field:MinecraftServer/serverStopped^ = true;
			}">stopServer
			</insertBefore>
			<synchronize>stopServer</synchronize>
			<public field="mcServer"/>
			<volatile field="serverRunning"/>
			<volatile field="serverIsRunning"/>
			<profile>runQueuedTasks</profile>
		</class>
		<class id="net.minecraft.server.MinecraftServer" env="mcpc">
			<replaceInitializer field="worlds" class="nallar.collections.ListSet"/>
			<replaceMethod code="{
						this.server.getScheduler().mainThreadHeartbeat(^field:MinecraftServer/tickCounter^);
					}">spigotTLETick
			</replaceMethod>
			<final field="processQueue"/>
			<replaceInitializer field="processQueue" code="$_ = runQueue;"/>
		</class>
		<class id="net.minecraft.server.MinecraftServer" env="forge">
			<addAll fromClass="nallar.patched.server.PatchMinecraftServerForge"/>
		</class>
		<class id="net.minecraft.profiler.Profiler">
			<addAll fromClass="nallar.patched.PatchProfiler"/>
		</class>
		<class id="net.minecraft.network.NetServerHandler">
			<replaceMethodCall method="^class:ILogAgent^.^method:ILogAgent/logWarning^"
							   code="{ nallar.tickthreading.global.Redirects.notifyAdmins($1); }"
					>handleFlying
			</replaceMethodCall>
			<insertBefore code="if (nallar.tickthreading.global.Redirects.interceptPacket($1, this)) { return; }">
				sendPacketToPlayer
			</insertBefore>
		</class>
		<class id="net.minecraft.network.packet.Packet10Flying">
			<addAll fromClass="nallar.patched.network.PatchPacket10Flying"/>
		</class>
		<class id="net.minecraft.network.packet.Packet14BlockDig">
			<addAll fromClass="nallar.patched.network.PatchPacketAsync"/>
		</class>
		<class id="net.minecraft.network.packet.Packet51MapChunk">
			<volatile field="chunkData"/>
			<addAll fromClass="nallar.patched.network.PatchPacket51MapChunk"/>
			<threadLocal field="temp" type="byte[]"
						 threadLocalField="nallar.tickthreading.global.ThreadLocals.mapChunkTempByteArray">
				getMapChunkData
			</threadLocal>
			<synchronize field="$1">getMapChunkData</synchronize>
		</class>
		<class id="net.minecraft.network.packet.Packet56MapChunks">
			<volatile field="chunkDataBuffer"/>
		</class>
		<class id="net.minecraft.network.packet.Packet254ServerPing">
			<addAll fromClass="nallar.patched.network.PatchPacketAsync"/>
		</class>
		<class id="net.minecraft.network.NetworkListenThread">
			<synchronize>addPlayer,networkTick</synchronize>
			<profile>networkTick</profile>
		</class>
		<class id="net.minecraft.network.TcpWriterThread">
			<ignoreExceptions type="java.net.SocketException">run</ignoreExceptions>
		</class>
		<class id="net.minecraft.world.World">
			<addAll fromClass="nallar.patched.world.PatchWorld"/>
			<profile>updateEntities</profile>
			<profile>setActivePlayerChunksAndCheckLight</profile>
			<final field="worldAccesses"/>
			<final field="provider"/>
			<final field="theProfiler"/>
			<!--
			Removed due to MFR grinder being annoying and creating a proxy worldserver as an overcomplicated workaround
			<final field="playerEntities"/>
			<final field="isRemote"/>
			-->
			<public field="ambientTickCountdown"/>
			<public field="forcedChunks"/>
			<replaceInitializer field="playerEntities" class="java.util.concurrent.CopyOnWriteArrayList"/>
			<replaceInitializer field="weatherEffects" class="nallar.collections.SynchronizedList"/>
			<insertBefore code="if (preHandleSpawn($1)) { return false; }">spawnEntityInWorld</insertBefore>
		</class>
		<class id="net.minecraft.world.World" env="mcpc">
			<removeUntilOpcode index="-2" opcode="ATHROW">addEntity,removePlayerEntityDangerously</removeUntilOpcode>
			<final field="captureTreeGeneration"/>
			<final field="captureBlockStates"/>
			<final field="capturedBlockStates"/>
			<final field="capturedItems"/>
			<newField field="inCaptureBlockStates" class="nallar.tickthreading.util.BooleanThreadLocalDefaultFalse"/>
			<newField field="inBlockStates" class="nallar.tickthreading.util.ArrayListThreadLocal"/>
			<newField field="inItems" class="nallar.tickthreading.util.ArrayListThreadLocal"/>
		</class>
		<class id="
		org.bukkit.craftbukkit.v1_6_R3.CraftWorld
		net.minecraft.item.ItemStack
		net.minecraft.world.World
		net.minecraft.block.Block
		net.minecraft.block.BlockSapling
		" env="mcpc">
			<replaceFieldUsage writeCode="{ }" readCode="{ $_ = false; }" field="captureTreeGeneration">^all^</replaceFieldUsage>
			<threadLocalBoolean field="captureBlockStates" threadLocalField="$0.inCaptureBlockStates"/>
			<threadLocal field="capturedBlockStates" type="java.util.ArrayList" threadLocalField="$0.inBlockStates"/>
			<threadLocal field="capturedItems" type="java.util.ArrayList" threadLocalField="$0.inItems"/>
		</class>
		<class id="net.minecraft.world.World" env="mcpc">
			<removeFieldAndInitializers field="captureBlockStates"/>
			<removeFieldAndInitializers field="captureTreeGeneration"/>
			<removeFieldAndInitializers field="capturedBlockStates"/>
			<removeFieldAndInitializers field="capturedItems"/>
		</class>
		<class id="net.minecraft.world.ChunkCache">
			<replaceMethodCall code="$_ = $0.getChunkIfExists($$);"
							   method="^class:World^.^method:World/getChunkFromChunkCoords^"/>
		</class>
		<class id="net.minecraft.world.NextTickListEntry">
			<newField static="" field="nextEntryID_" class="java.util.concurrent.atomic.AtomicLong"/>
			<insertAfter field="tickEntryID" code="this.$field = this.nextEntryID_.getAndIncrement();"/>
		</class>
		<class id="net.minecraft.world.WorldServer" env="forge">
			<removeInitializers field="pendingTickListEntriesHashSet"/>
			<removeInitializers field="pendingTickListEntriesTreeSet"/>
		</class>
		<class id="net.minecraft.world.WorldServer">
			<addAll fromClass="nallar.patched.world.PatchWorldServer"/>
			<profile>tickBlocksAndAmbiance</profile>
			<profile>tick</profile>
			<insertSuper>initialize</insertSuper>
		</class>
		<class id="net.minecraft.world.ServerBlockEventList">
			<public/>
		</class>
		<class id="net.minecraft.world.biome.BiomeDecorator">
			<synchronize>decorate(Lnet/minecraft/world/World;Ljava/util/Random;II)V</synchronize>
		</class>
		<class id="net.minecraft.world.biome.WorldChunkManager">
			<newField field="staticLock" class="java.lang.Object" static=""/>
			<!--<synchronize field="staticLock">getModdedBiomeGenerators</synchronize>-->
		</class>
		<class id="net.minecraft.world.biome.BiomeCache">
			<synchronize>getBiomeCacheBlock,cleanupCache</synchronize>
		</class>
		<class id="net.minecraft.world.gen.layer.IntCache">
			<replace class="nallar.patched.storage.IntCache"/>
		</class>
		<class id="net.minecraft.world.gen.structure.MapGenStructure">
			<replaceInitializer field="structureMap" class="java.util.concurrent.ConcurrentHashMap"/>
		</class>
		<class id="net.minecraft.world.gen.ChunkProviderServer">
			<replace class="nallar.patched.storage.ThreadedChunkProvider"/>
			<lockToSynchronized>getChunkAtInternal</lockToSynchronized>
			<profile>tick</profile>
		</class>
		<class id="net.minecraft.world.gen.ChunkProviderServer" env="mcpc">
			<replaceMethod code="{
				world.getServer().getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent($1.bukkitChunk, $2));
			}
			">fireBukkitLoadEvent
			</replaceMethod>
			<replaceMethod code="{
				world.getServer().getPluginManager().callEvent(new org.bukkit.event.world.ChunkPopulateEvent($1.bukkitChunk));
			}
			">fireBukkitPopulateEvent
			</replaceMethod>
			<replaceMethod code="{
				org.bukkit.event.world.ChunkUnloadEvent event = new org.bukkit.event.world.ChunkUnloadEvent($1.bukkitChunk);
        world.getServer().getPluginManager().callEvent(event);

        return !event.isCancelled();
			}
			">fireBukkitUnloadEvent
			</replaceMethod>
		</class>
		<class id="org.bukkit.craftbukkit.v1_6_R3.chunkio.ChunkIOExecutor" env="mcpc">
			<replaceInitializer field="instance" code="$_ = null;"/>
			<replaceMethod code="throw new UnsupportedOperationException();">tick</replaceMethod>
			<disable>adjustPoolSize</disable>
			<replaceMethod
					code="return $3.getChunkAt($4, $5, true, false, null);">
				syncChunkLoad
			</replaceMethod>
			<replaceMethod code="$3.getChunkAt($4, $5, true, false, $6);">queueChunkLoad</replaceMethod>
		</class>
		<class id="net.minecraft.world.gen.ChunkProviderServer" env="mcpc">
			<changeFieldType field="chunksToUnload" type="org.bukkit.craftbukkit.v1_6_R3.util.LongHashSet"
							 remove="true"/>
			<insertAfter field="chunksToUnload" code="$field = new org.bukkit.craftbukkit.v1_6_R3.util.LongHashSet();"/>
		</class>
		<class id="net.minecraft.world.chunk.NibbleArray" env="forge">
			<addAll fromClass="nallar.patched.storage.PatchNibbleArrayForge"/>
		</class>
		<class id="net.minecraft.world.chunk.storage.RegionFileCache">
			<replaceMethod code="throw new UnsupportedOperationException();">createOrLoadRegionFile</replaceMethod>
		</class>
		<class id="net.minecraft.world.chunk.storage.AnvilChunkLoader">
			<replace class="nallar.patched.storage.ThreadedChunkLoader"/>
		</class>
		<class id="net.minecraft.world.chunk.storage.AnvilChunkLoaderPending">
			<addAll fromClass="nallar.patched.storage.PatchAnvilChunkLoaderPending"/>
		</class>
		<class id="net.minecraft.world.chunk.Chunk">
			<!-- The entity list could be accessed from multiple threads, as usual causes problems during iteration -->
			<addAll fromClass="nallar.patched.storage.PatchChunk"/>
			<final field="xPosition"/>
			<final field="zPosition"/>
			<final field="entityLists"/>
			<final field="worldObj"/>
			<final field="chunkTileEntityMap"/>
			<final field="tileMap"/>
			<volatile field="isTerrainPopulated"/>
			<replaceInitializer field="chunkTileEntityMap" class="nallar.collections.CHashMap"/>
			<!--
			Used to debug when mods are setting chunk.isModified when they shouldn't - for example, GregTech sets every chunk with a gregtech machine in as modified
			every tick. :(
			<replaceFieldUsage field="isModified" writeCode="$0.^field:Chunk/isModified^ = $1; if ($1 == true) { Thread.dumpStack(); }">^all^</replaceFieldUsage>
			-->
		</class>
		<class id="net.minecraft.world.chunk.EmptyChunk">
			<replaceMethod code="return 1;">getHeightValue</replaceMethod>
			<replaceMethod code="{ if ($2 == 0) { return 7; } return 0; }">getBlockID</replaceMethod>
		</class>
		<class id="net.minecraft.util.MathHelper">
			<final field="SIN_TABLE"/>
		</class>
		<class id="net.minecraft.util.Vec3Pool">
			<!-- This prevents entities in multiple threads using the same Vec3 for collisions. -->
			<replace class="nallar.patched.PatchVec3Pool"/>
		</class>
		<class id="net.minecraft.util.Vec3">
			<addAll fromClass="nallar.patched.PatchVec3"/>
		</class>
		<class id="net.minecraft.util.AABBPool">
			<!-- This prevents entities in multiple threads using the same Vec3 for collisions. -->
			<replace class="nallar.patched.PatchAABBPool"/>
		</class>
		<class id="net.minecraft.util.AxisAlignedBB">
			<!-- Improves performance -->
			<addAll fromClass="nallar.patched.PatchAxisAlignedBB"/>
			<removeFieldAndInitializers field="theAABBLocalPool"/>
			<replaceMethod code="return aabbPool;">getAABBPool</replaceMethod>
		</class>
		<class id="net.minecraft.util.LongHashMap">
			<replace class="nallar.patched.collection.PatchLongHashMap"/>
		</class>
		<class id="net.minecraft.util.IntHashMap">
			<replace class="nallar.patched.collection.PatchIntHashMap"/>
		</class>
		<class id="net.minecraft.entity.DataWatcher">
			<replace class="nallar.patched.entity.PatchDataWatcher"/>
		</class>
		<class id="net.minecraft.entity.passive.EntitySquid" env="forge">
			<!-- This patch is already included in MCPC+ as it's in Spigot -->
			<removeMethod>isInWater</removeMethod>
		</class>
		<class id="net.minecraft.entity.player.EntityPlayerMP">
			<addAll fromClass="nallar.patched.entity.PatchEntityPlayerMP"/>
			<!-- Concurrent access during iteration = boom -->
			<replaceInitializer field="destroyedItemsNetCache" class="nallar.collections.ConcurrentQueueList"/>
			<replaceInitializer field="loadedChunks" class="nallar.collections.ConcurrentQueueList"/>
		</class>
		<class id="net.minecraft.entity.player.EntityPlayerMP" env="forge">
			<addAll fromClass="nallar.patched.entity.PatchEntityPlayerMPForge"/>
		</class>
		<class id="net.minecraft.entity.player.EntityPlayerMP" env="mcpc">
			<insertBefore code="{
				if (this.^field:Entity/hurtResistantTime^ > 0){
					--this.^field:Entity/hurtResistantTime^;
				}
			}">onUpdate</insertBefore>
		</class>
		<class id="net.minecraft.nbt.CompressedStreamTools">
			<addAll fromClass="nallar.patched.nbt.PatchCompressedStreamTools"/>
		</class>
		<class id="net.minecraft.nbt.NBTBase">
			<replaceMethod code="{
				byte id = $1.^method:NBTBase/getId^();
				$2.writeByte(id);

				if (id != 0) {
					$2.writeUTF($1.^method:NBTBase/getName^());
					if (id == 10) {
						synchronized ($1) {
							$1.^method:NBTBase/write^($2);
						}
					} else {
						$1.^method:NBTBase/write^($2);
					}
				}
			}">writeNamedTag
			</replaceMethod>
		</class>
		<class id="net.minecraft.nbt.NBTBase">
			<addAll fromClass="nallar.patched.nbt.PatchNBTBase"/>
		</class>
		<class id="net.minecraft.nbt.NBTTagCompound">
			<addAll fromClass="nallar.patched.nbt.PatchNBTTagCompound"/>
			<replaceInitializer field="tagMap" class="nallar.collections.PartiallySynchronizedMap"/>
		</class>
		<class id="net.minecraft.entity.Entity">
			<addAll fromClass="nallar.patched.entity.PatchEntity"/>
		</class>
		<class id="net.minecraft.entity.Entity">
			<final field="rand"/>
			<newField static="" field="nextEntityID_" class="java.util.concurrent.atomic.AtomicInteger"/>
			<insertAfter field="entityId" code="this.$field = this.nextEntityID_.getAndIncrement();"/>
			<insertBefore code="if ($1 == 0 &amp;&amp; $2 == 0 &amp;&amp; $3 == 0) { return; }">moveEntity
			</insertBefore>
		</class>
		<class id="net.minecraft.entity.EntityLiving">
			<addAll fromClass="nallar.patched.entity.PatchEntityLiving"/>
			<insertSuper>onLivingUpdate</insertSuper>
		</class>
		<class id="net.minecraft.entity.EntityLivingBase">
			<addAll fromClass="nallar.patched.entity.PatchEntityLivingBase"/>
		</class>
		<class id="net.minecraft.entity.item.EntityItem">
			<addAll fromClass="nallar.patched.entity.PatchEntityItem"/>
			<insertSuper>onUpdate</insertSuper>
		</class>
		<class id="net.minecraft.entity.item.EntityXPOrb">
			<addAll fromClass="nallar.patched.entity.PatchEntityXPOrb"/>
		</class>
		<class id="net.minecraft.tileentity.TileEntity">
			<addAll fromClass="nallar.patched.PatchTileEntity"/>
		</class>
		<class id="net.minecraft.entity.EntityTrackerEntry" env="mcpc">
			<removeUntilOpcode index="-2" opcode="ATHROW">tryStartWachingThis,removePlayerFromTracker
			</removeUntilOpcode>
		</class>
		<class id="net.minecraft.entity.EntityTracker" env="mcpc">
			<removeUntilOpcode index="-2" opcode="ATHROW">
				removeEntityFromAllTrackingPlayers,addEntityToTracker(Lnet/minecraft/entity/Entity;IIZ)V
			</removeUntilOpcode>
		</class>
		<class id="net.minecraft.entity.EntityTracker">
			<!-- Yet more comodification exceptions -->
			<addAll fromClass="nallar.patched.entity.PatchEntityTracker"/>
			<newField field="readWriteLock" class="nallar.tickthreading.util.concurrent.TwoWayReentrantReadWriteLock"/>
			<newField field="writeLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.writeLock();"/>
			<newField field="readLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.readLock();"/>
			<lock field="writeLock">
				addEntityToTracker(Lnet/minecraft/entity/Entity;)V,addEntityToTracker(Lnet/minecraft/entity/Entity;IIZ)V,removeEntityFromAllTrackingPlayers
			</lock>
			<lock field="readLock">updateTrackedEntities,removePlayerFromTrackers,func_85172_a</lock>
		</class>
		<class id="net.minecraft.village.Village">
			<addAll fromClass="nallar.patched.PatchVillage"/>
		</class>
		<class id="net.minecraft.village.VillageCollection">
			<addAll fromClass="nallar.patched.collection.PatchVillageCollection"/>
			<!-- Literally the most useless collection. Locking instead of voiding in case it ever does something useful in future -->
			<newField field="readWriteLock" class="nallar.tickthreading.util.concurrent.TwoWayReentrantReadWriteLock"/>
			<newField field="writeLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.writeLock();"/>
			<newField field="readLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.readLock();"/>
			<lock field="writeLock">addVillagerPosition</lock>
			<lock field="readLock">findNearestVillage,func_82566_a</lock>
		</class>
		<class id="net.minecraft.server.dedicated.DedicatedServerSleepThread">
			<disable>run</disable>
		</class>
		<class id="net.minecraft.server.management.ServerConfigurationManager">
			<addAll fromClass="nallar.patched.server.PatchServerConfigurationManager"/>
			<newField field="readWriteLock" class="nallar.tickthreading.util.concurrent.TwoWayReentrantReadWriteLock"/>
			<newField field="playersUpdateLock" class="java.util.concurrent.locks.Lock"
					  code="this.readWriteLock.writeLock();"/>
			<newField field="playerUpdateLock" class="java.util.concurrent.locks.Lock"
					  code="this.readWriteLock.readLock();"/>
			<lock field="playerUpdateLock">createPlayerForUser,sendPacketToAllPlayers,sendPlayerInfoToAllPlayers</lock>
			<lock field="playerUpdateLock">
				sendPacketToAllPlayersInDimension,getPlayerListAsString,getAllUsernames,getPlayerForUsername,findPlayers,sendToAllNearExcept
			</lock>
			<lock field="playerUpdateLock">saveAllPlayerData,getPlayerList</lock>
			<replaceInitializer field="playerEntityList" class="nallar.collections.LockArrayList"/>
			<insertAfter
					code="((nallar.collections.LockArrayList)^field:ServerConfigurationManager/playerEntityList^).lock = playersUpdateLock;"/>
			<synchronize field="$1.playerNetServerHandler">respawnPlayer</synchronize>
			<synchronize field="$1.^field:EntityPlayerMP/playerNetServerHandler^">
				transferPlayerToDimension(L^class:EntityPlayerMP^;IL^class:Teleporter^;)V
			</synchronize>
		</class>
		<class id="net.minecraft.server.management.ServerConfigurationManager" env="forge">
			<addAll fromClass="nallar.patched.server.PatchServerConfigurationManagerForge"/>
		</class>
		<class id="net.minecraft.server.management.PlayerManager">
			<addAll fromClass="nallar.patched.world.tracking.PatchPlayerManager"/>
			<replaceMethodCall method="sort" index="1" code="{ }">updateMountedMovingPlayer</replaceMethodCall>
			<synchronize>addPlayer,removePlayer</synchronize>
			<synchronize field="$1.loadedChunks">addPlayer,removePlayer,filterChunkLoadQueue</synchronize>
			<synchronize field="$1.loadedChunks">updateMountedMovingPlayer</synchronize>
			<profile>updatePlayerInstances</profile>
		</class>
		<class id="net.minecraft.server.management.PlayerInstance" env="forge">
			<replaceMethodCall method="^class:ChunkProviderServer^.^method:ChunkProviderServer/loadChunk^"
							   code="{ $_ = null; }"/>
		</class>
		<class id="net.minecraft.server.management.PlayerInstance">
			<replaceInitializer field="playersInChunk" code="$_ = Collections.synchronizedList(new ArrayList());"/>
			<replaceMethodCall method="^class:PlayerManager^.^method:PlayerManager/getWorldServer^" removeAfter="true"/>
			<addAll fromClass="nallar.patched.world.tracking.PatchPlayerInstance"/>
			<public field="loaded"/>
			<final field="chunkLocation"/>
		</class>
		<class id="net.minecraft.world.ChunkCoordIntPair">
			<addAll fromClass="nallar.patched.storage.PatchChunkCoordIntPair"/>
			<public field="chunkXPos"/>
			<public field="chunkZPos"/>
			<noFinal field="chunkXPos"/>
			<noFinal field="chunkZPos"/>
		</class>
		<class id="net.minecraft.world.Teleporter">
			<replaceMethodCall newMethod="getTEWithLoad" method="^class:WorldServer^.^method:World/getBlockTileEntity^">
				^all^
			</replaceMethodCall>
			<replaceMethodCall newMethod="getBlockIdWithLoad" method="^class:WorldServer^.^method:World/getBlockId^">
				^all^
			</replaceMethodCall>
		</class>
		<class id="net.minecraft.crash.CrashReport">
			<addAll fromClass="nallar.patched.server.PatchCrashReport"/>
		</class>
		<class id="net.minecraft.block.BlockRedstoneTorch">
			<addAll fromClass="nallar.patched.block.PatchBlockRedstoneTorch"/>
		</class>
		<class id="net.minecraft.block.BlockRedstoneWire">
			<synchronize>calculateCurrentChanges,updateAndPropagateCurrentStrength</synchronize>
		</class>
		<class id="net.minecraft.block.BlockFlowing">
			<!--
				TODO: Make this cleaner once it's possible to access method parameters while replacing a MethodCall expression.
				See https://issues.jboss.org/browse/JASSIST-197
			-->
			<replaceMethodCall
					code="if (((org.bukkit.craftbukkit.v1_6_R3.CraftWorld) ((org.bukkit.event.block.BlockEvent) $1).getBlock().getWorld()).getHandle().safeToGenerate()) { $0.callEvent($$); }"
					method="callEvent">updateTick
			</replaceMethodCall>
		</class>
		<class id="net.minecraft.network.TcpConnection">
			<addAll fromClass="nallar.patched.network.PatchTcpConnection"/>
		</class>
		<class id="net.minecraft.network.TcpReaderThread">
			<replace class="nallar.patched.network.ReplaceTcpReaderThread"/>
		</class>
		<class id="net.minecraft.entity.ai.EntityAITasks">
			<synchronize>addTask,func_85156_a,onUpdateTasks,func_75775_b</synchronize>
		</class>
		<class id="net.minecraft.server.gui.TextAreaLogHandler">
			<synchronize>publish</synchronize>
		</class>
		<!--suppress DeprecatedClassUsageInspection -->
		<class id="net.minecraftforge.liquids.LiquidTank">
			<synchronize/>
		</class>
		<class id="net.minecraftforge.common.DimensionManager">
			<addAll fromClass="nallar.patched.forge.PatchDimensionManager"/>
			<synchronize field="unloadQueue">unloadWorld</synchronize>
			<insertBefore code="if (getWorld($1) != null) { return; }">initDimension</insertBefore>
			<synchronize>unloadWorlds,initDimension,setWorld</synchronize>
			<insertAfter code="if ($2 != null) { $2.setDimension($1); }">setWorld</insertAfter>
		</class>
		<class id="net.minecraftforge.common.DimensionManager" env="mcpc">
			<replaceMethod code="{
				org.bukkit.event.world.WorldUnloadEvent e = new org.bukkit.event.world.WorldUnloadEvent($1.getWorld());
				org.bukkit.Bukkit.getServer().getPluginManager().callEvent(e);
				return e.isCancelled();
			}
			">fireBukkitWorldUnload
			</replaceMethod>
			<replaceMethod code="{
				org.bukkit.Bukkit.getServer().getPluginManager().callEvent(new org.bukkit.event.world.WorldSaveEvent($1.getWorld()));
			}
			">fireBukkitWorldSave
			</replaceMethod>
			<replaceMethod code="{
				java.lang.reflect.Field field = org.bukkit.Bukkit.getServer().getClass().getDeclaredField(&quot;worlds&quot;);
				field.setAccessible(true);
				((java.util.Map) field.get(org.bukkit.Bukkit.getServer())).values().remove($1.getWorld());
			}
			">removeBukkitWorld
			</replaceMethod>
			<removeUntilOpcode opcode="return" index="1">initDimension</removeUntilOpcode>
		</class>
		<class id="net.minecraft.pathfinding.PathNavigate">
			<synchronize>setPath,onUpdateNavigation</synchronize>
		</class>
	</minecraftCommon>
	<bukkit>
		<class id="org.bukkit.plugin.SimplePluginManager">
			<synchronize>
				subscribeToPermission,unsubscribeFromPermission,subscribeToDefaultPerms,unsubscribeFromDefaultPerms,getPermissionSubscriptions,getDefaultPermSubscriptions
			</synchronize>
			<replaceMethod code="{ fireEvent($$); }">callEvent</replaceMethod>
		</class>
		<class id="org.bukkit.craftbukkit.v1_6_R3.util.ShortConsoleLogFormatter">
			<addAll fromClass="nallar.log.LogFormatter"/>
		</class>
		<class id="org.bukkit.craftbukkit.v1_6_R3.CraftServer">
			<replaceMethodCall method="registerDimension" code="{ }">
				createWorld(Lorg.bukkit.WorldCreator;)Lorg.bukkit.World;
			</replaceMethodCall>
			<replaceMethodCall method="addMVDimension" code="{ }">
				createWorld(Lorg.bukkit.WorldCreator;)Lorg.bukkit.World;
			</replaceMethodCall>
			<ignoreExceptions
					code="System.err.println(&quot;Loading world failed&quot; + $e); $e.printStackTrace(); throw new java.lang.Error($e);">
				createWorld(Lorg.bukkit.WorldCreator;)Lorg.bukkit.World;
			</ignoreExceptions>
			<replaceMethod code="{
				return net.minecraftforge.common.DimensionManager.unloadWorld(((org.bukkit.craftbukkit.v1_6_R3.CraftWorld) $1).getHandle(), $2);
			}">unloadWorld(Lorg.bukkit.World;Z)V
			</replaceMethod>
		</class>
		<class id="org.bukkit.craftbukkit.v1_6_R3.entity.CraftPlayer">
			<removeUntilOpcode index="-2" opcode="ATHROW">kickPlayer</removeUntilOpcode>
		</class>
		<class id="org.bukkit.craftbukkit.v1_6_R3.CraftWorld">
			<removeUntilOpcode index="-2" opcode="ATHROW">unloadChunkRequest(IIZ)Z,unloadChunk(IIZ)Z,loadChunk(IIZ)Z</removeUntilOpcode>
			<replaceMethod
					code=" {
							Object[] chunks = world.getChunks();
							org.bukkit.Chunk[] craftChunks = new org.bukkit.Chunk[chunks.length];
							for (int i = 0; i &lt; craftChunks.length; i++) {
								craftChunks[i] = ((^class:Chunk^) chunks[i]).bukkitChunk;
							}
							return craftChunks;
							} "
					>getLoadedChunks
			</replaceMethod>
			<replaceFieldUsage class="^class:WorldServer^" field="^field:World/loadedEntityList^"
							   readCode="$_ = world.getEntities();">
				getLivingEntities,getEntities,getEntitiesByClass(Ljava.lang.Class;)Ljava.util.Collection;,getEntitiesByClasses
			</replaceFieldUsage>
			<replaceFieldUsage class="^class:WorldServer^" field="^field:World/loadedEntityList^"
							   readCode="$_ = world.getPlayerEntities();">getPlayers
			</replaceFieldUsage>
			<replaceMethod
					code=" {
								return world.^field:WorldServer/theChunkProviderServer^.getChunkAt($1, $2, $3, null) != null;
							} "
					>loadChunk(IIZ)Z
			</replaceMethod>
			<replaceMethod
					code=" {
								if ($4 &amp;&amp; isChunkInUse($1, $2)) {
										return false;
								}

								world.^field:WorldServer/theChunkProviderServer^.unloadChunkImmediately($1, $2, $3);

								return true;
							} "
					>unloadChunk(IIZZ)Z
			</replaceMethod>
			<replaceMethod
					code=" {
								world.^field:WorldServer/theChunkProviderServer^.regenerateChunk($1, $2);

								refreshChunk($1, $2);

								return true;
							} "
					>regenerateChunk
			</replaceMethod>
			<replaceMethod code="throw new UnsupportedOperationException(&quot;Not threadsafe.&quot;);">
				chunkLoadPostProcess
			</replaceMethod>
			<disable>processChunkGC</disable>
		</class>
	</bukkit>
	<spigot>
		<class id="org.spigotmc.WatchdogThread">
			<disable>run</disable>
		</class>
		<class id="org.spigotmc.CustomTimingsHandler">
			<replaceInitializer field="ALL_HANDLERS" class="nallar.collections.SynchronizedSet"/>
		</class>
	</spigot>
	<forge>
		<class id="net.minecraftforge.common.Configuration">
			<addAll fromClass="nallar.patched.forge.PatchConfiguration"/>
		</class>
		<class id="net.minecraftforge.common.ConfigCategory">
			<addAll fromClass="nallar.patched.forge.PatchConfigCategory"/>
		</class>
		<class id="net.minecraftforge.common.ForgeChunkManager$Ticket">
			<public all="true"/>
		</class>
		<class id="net.minecraftforge.common.ForgeChunkManager" env="mcpc">
			<removeFieldAndInitializers field="forcedChunks" silent="true"/>
		</class>
		<class id="net.minecraftforge.common.ForgeChunkManager">
			<addAll fromClass="nallar.patched.forge.PatchForgeChunkManager"/>
		</class>
	</forge>
	<forgeModLoader>
		<class id="cpw.mods.fml.common.registry.GameRegistry">
			<addAll fromClass="nallar.patched.forge.PatchGameRegistry"/>
		</class>
		<class id="cpw.mods.fml.common.registry.TickRegistry">
			<addAll fromClass="nallar.patched.forge.PatchTickRegistry"/>
            <synchronize>updateTickQueue,registerScheduledTickHandler</synchronize>
		</class>
		<class id="cpw.mods.fml.relauncher.FMLLogFormatter">
			<replace class="nallar.log.LogFormatter"/>
		</class>
		<class id="cpw.mods.fml.common.event.FMLInterModComms$IMCMessage">
			<addAll fromClass="nallar.patched.forge.PatchIMCMessage"/>
		</class>
		<class id="cpw.mods.fml.common.Loader$ModIdComparator">
			<public/>
		</class>
		<class id="cpw.mods.fml.common.FMLModContainer">
			<replaceMethodCall index="0" code="{ $_ = null; }" method="log">constructMod</replaceMethodCall>
			<replaceFieldUsage field="fingerprintNotPresent" readCode="$_ = false;">constructMod</replaceFieldUsage>
		</class>
		<class id="cpw.mods.fml.common.registry.BlockTracker">
			<synchronize>getNextBlockId,doReserveId</synchronize>
		</class>
		<class id="cpw.mods.fml.common.FMLCommonHandler">
			<addAll fromClass="nallar.patched.forge.PatchFMLCommonHandler"/>
			<profile>onPreServerTick,onPostServerTick,onPreWorldTick,onPostWorldTick</profile>
		</class>
		<class id="cpw.mods.fml.common.network.PacketDispatcher">
			<addAll fromClass="nallar.patched.forge.PatchPacketDispatcher"/>
		</class>
		<class id="cpw.mods.fml.common.network.ModListResponsePacket">
			<replaceMethodCall index="2" code="{ $_ = null; }" method="info">execute</replaceMethodCall>
		</class>
	</forgeModLoader>
	<factorization>
		<class id="factorization.weird.TileEntityBarrel">
			<replaceMethod code="{
				^class:ItemStack^ i = this.item;
				if (i == null) {
					return 0;
				}
				^class:ItemStack^ top = this.topStack;
				^class:ItemStack^ b = this.bottomStack;
				if ((top == null) || (!itemMatch(top))) {
					top = i.^method:ItemStack/copy^();
					top.^field:ItemStack/stackSize^ = 0;
					this.topStack = top;
				}
				if ((b == null) || (!itemMatch(b))) {
					b = i.^method:ItemStack/copy^();
					b.^field:ItemStack/stackSize^ = 0;
					this.bottomStack = b;
				}
				return top.^field:ItemStack/stackSize^ + this.middleCount + b.^field:ItemStack/stackSize^;
			}">getItemCount
			</replaceMethod>
			<synchronize>updateStacks,changeItemCount,setItemCount</synchronize>
		</class>
		<class id="factorization.charge.TileEntityMirror">
			<replaceMethod code="{
				this.next_check = (300 + rand.nextInt(60));
			}">setNextCheck
			</replaceMethod>
		</class>
		<class id="factorization.wrath.TileEntityRouter">
			<newField field="emptyUpdateCount" class="int" code="0" static=""/>
			<replaceMethod code="{
				if (this.^field:TileEntity/worldObj^.^method:World/isBlockGettingPowered^(this.^field:TileEntity/xCoord^, this.^field:TileEntity/yCoord^, this.^field:TileEntity/zCoord^)) {
					return false;
				}
				if (this.is_input) {
					return this.buffer != null;
				}
				if (this.buffer == null) {
					return ++emptyUpdateCount % 5 == 0;
				}

				return this.buffer.^field:ItemStack/stackSize^ &lt; this.buffer.^method:ItemStack/getMaxStackSize^();
			}">shouldUpdate
			</replaceMethod>
		</class>
		<class id="factorization.charge.TileEntitySolarBoiler">
			<synchronize>addReflector</synchronize>
		</class>
		<class id="factorization.wrath.TileEntityWrathLamp">
			<replaceInitializer field="airToUpdate" class="nallar.collections.SynchronizedPriorityQueue">^static^
			</replaceInitializer>
			<threadLocal field="toVisit" type="java.util.HashSet"
						 threadLocalField="nallar.tickthreading.global.ThreadLocals.factorizationFindLightAirParentToVisit"/>
			<replaceMethodCall code="$_ = $0.getChunkFromBlockCoordsIfExists($$);"
							   method="^class:World^.^method:World/getChunkFromBlockCoords^">findLightAirParent
			</replaceMethodCall>
		</class>
		<class id="factorization.api.Charge">
			<newField field="staticLock" class="java.lang.Object" static=""/>
			<synchronize field="staticLock">update</synchronize>
		</class>
	</factorization>
	<liteLoader>
		<class id="com.mumfrey.liteloader.core.HookProfiler">
			<!-- LiteLoader makes the profiler not threadsafe - I may look into patching this better in future, but TT isn't really intended for clients -->
			<synchronize>a(Ljava/lang/String;)V,b()V</synchronize>
		</class>
	</liteLoader>
	<buildCraftCore>
		<class id="buildcraft.core.EntityRobot">
			<synchronize>build</synchronize>
		</class>
	</buildCraftCore>
	<buildCraftFactory>
		<class id="buildcraft.BuildCraftFactory$QuarryChunkloadCallback">
			<replaceMethodCall newMethod="getTEWithLoad" method="^class:World^.^method:World/getBlockTileEntity^">
				ticketsLoaded(Ljava.util.List;L^class:World^;)V
			</replaceMethodCall>
			<replaceMethodCall newMethod="getBlockIdWithLoad" method="^class:World^.^method:World/getBlockId^">
				ticketsLoaded(Ljava.util.List;L^class:World^;I)Ljava.util.List;
			</replaceMethodCall>
		</class>
	</buildCraftFactory>
	<thermalExpansionPlugins>
		<class id="thermalexpansion.plugins.cc.TurtleWrench">
			<ignoreExceptions type="java.lang.NullPointerException" code="return false;">attack</ignoreExceptions>
		</class>
	</thermalExpansionPlugins>
	<thermalExpansionTransport>
		<class id="thermalexpansion.part.conduit.GridFormer">
			<newField field="tickLock" class="java.lang.Object" static=""/>
			<synchronize field="tickLock">setup</synchronize>
		</class>
		<class id="thermalexpansion.part.conduit.GridTickHandler">
			<replaceInitializer field="tickingGrids" class="nallar.collections.CLinkedHashSet"/>
			<replaceInitializer field="tickingGridsToAdd" class="nallar.collections.CLinkedHashSet"/>
			<replaceInitializer field="tickingGridsToRemove" class="nallar.collections.CLinkedHashSet"/>
			<replaceInitializer field="tickConduit" class="nallar.collections.CLinkedHashSet"/>
			<replaceInitializer field="tickConduitToAdd" class="nallar.collections.CLinkedHashSet"/>
			<synchronize field="thermalexpansion.part.conduit.GridFormer.tickLock">tickEnd</synchronize>
		</class>
		<class id="thermalexpansion.part.conduit.ConduitBase">
			<synchronize field="thermalexpansion.part.conduit.GridFormer.tickLock">load,onChunkUnload</synchronize>
		</class>
		<class id="thermalexpansion.part.conduit.Grid">
			<synchronize/>
			<synchronize field="thermalexpansion.part.conduit.GridFormer.tickLock">rebalanceGrid,nodeAdded,addConduit,removeConduit,makeNode,makeConduit,destroyGrid,regenerateGrid,mergeGrid,setUntransversed</synchronize>
		</class>
		<class id="thermalexpansion.part.conduit.fluid.GridFluid">
			<final field="worldObj"/>
			<insertAfter code="{
				if (worldObj == null) {
					throw new RuntimeException(&quot;Null worldObj in GridFluid construction from &quot; + String.valueOf($1));
				}
			}"/>
			<insertBefore code="{
				if (worldObj == null || worldObj.unloaded) {
					thermalexpansion.part.conduit.GridTickHandler.tickingGridsToRemove.add(this);
					System.err.println(&quot;Grid in unloaded or null world &quot; + String.valueOf(worldObj) + String.valueOf(this));
				}
			}">doGridUpdate</insertBefore>
			<synchronize/>
		</class>
		<class id="thermalexpansion.part.conduit.energy.GridEnergy">
			<synchronize/>
		</class>
	</thermalExpansionTransport>
	<industrialCraft>
		<class id="ic2.core.IC2">
			<synchronize>addSingleTickCallback</synchronize>
		</class>
		<class id="ic2.core.WorldData">
			<replaceInitializer field="mapping" class="nallar.collections.PartiallySynchronizedMap"/>
			<replaceMethod code="{
				ic2.core.WorldData ret = (ic2.core.WorldData) mapping.get($1);
				if (ret != null) {
					return ret;
				}
				synchronized (mapping) {
					ret = (ic2.core.WorldData) mapping.get($1);
					if (ret != null) {
						return ret;
					}
					ret = new ic2.core.WorldData();
					mapping.put($1, ret);
				}
				return ret;
			}">get</replaceMethod>
		</class>
		<class id="ic2.core.energy.EnergyNetLocal">
			<replaceMethod code="{
				Map changes = this.changes;
				synchronized (changes) {
					Double original = (Double) changes.get($1);
					if (original == null) {
						changes.put($1, Double.valueOf($2));
					} else {
						changes.put($1, Double.valueOf(original.doubleValue() + $2));
					}
				}
			}">addChange</replaceMethod>
			<synchronize field="changes">onTickEnd</synchronize>
			<synchronize field="grids">onTickEnd</synchronize>
			<synchronize field="registeredTiles">addTileEntity,removeTileEntity</synchronize>
			<replaceInitializer field="changes" class="nallar.collections.PartiallySynchronizedMap"/>
			<replaceInitializer field="registeredTiles" class="nallar.collections.PartiallySynchronizedMap"/>
			<replaceInitializer field="grids" class="nallar.collections.SynchronizedSet"/>
		</class>
		<class id="ic2.core.ExplosionIC2">
			<synchronize>doExplosion</synchronize>
		</class>
		<class id="ic2.core.block.wiring.TileEntityElectricBlock">
			<replaceMethodCall method="self.^method:TileEntity/onInventoryChanged^" code="{ }">
				^method:TileEntity/updateEntity^
			</replaceMethodCall>
		</class>
	</industrialCraft>
	<gregTech>
		<class id="gregtechmod.api.GregTech_API">
			<replaceNew oldClass="java.util.HashMap" newClass="nallar.collections.CHashMap"/>
		</class>
		<class id="gregtechmod.GT_Mod">
			<synchronize>readIDSUData,writeIDSUData</synchronize>
		</class>
		<class id="gregtechmod.common.tileentities.GT_TileEntityMetaID_Machine">
			<replaceMethodCall method="self.^method:TileEntity/onInventoryChanged^" code="{ }">
				^method:TileEntity/updateEntity^
			</replaceMethodCall>
		</class>
		<class id="gregtechmod.common.tileentities.GT_TileEntity_IDSU">
			<replaceMethodCall method="remove" code="{ $_ = null; }">setEnergyVar</replaceMethodCall>
		</class>
		<class id="gregtechmod.api.metatileentity.MetaTileEntity">
			<unvolatile field="VERSION"/>
			<final field="VERSION"/>
		</class>
		<class id="gregtechmod.api.metatileentity.BaseMetaTileEntity">
			<replaceFieldUsage field="mAverageEUInputIndex"
							   writeCode="mAverageEUInputIndex = $1 >= mAverageEUInput.length ? 0 : $1;">
				^method:TileEntity/updateEntity^
			</replaceFieldUsage>
			<replaceFieldUsage field="mAverageEUOutputIndex"
							   writeCode="mAverageEUOutputIndex = $1 >= mAverageEUOutput.length ? 0 : $1;">
				^method:TileEntity/updateEntity^
			</replaceFieldUsage>
			<replaceMethod code="{
				gregtechmod.api.metatileentity.MetaTileEntity m = mMetaTileEntity;
				return m != null &amp;&amp; m.getBaseMetaTileEntity() == this;
			}">hasValidMetaTileEntity
			</replaceMethod>
		</class>
		<class id="gregtechmod.api.metatileentity.BaseMetaTileEntityMJ" srg="true">
			<replaceMethod code="{
				if (hasMJConverterUpgrade()) {
					buildcraft.api.power.IPowerProvider p = mProvider;
					if (p == null) {
						synchronized(this) {
							p = mProvider;
							if (p == null) {
								p = buildcraft.api.power.PowerFramework.currentFramework.createPowerProvider();
								mProvider = p;
								p.configure(100, 1, 100, 1, 10000);
							}
						}
					}
					else {
						int c = getMJCapacity();
						if (c > 0) {
							int s = getStoredMJ();
							if (s &lt; c) {
								increaseStoredMJ((int)p.useEnergy(1.0F, (float) c - s, true), true);
							}
						}
					}
      	}
			}">updateStatus
			</replaceMethod>
			<replaceMethod code="{
				buildcraft.api.power.IPowerProvider powerProvider = getPowerProvider();
				if (powerProvider == null) {
					return 0;
				}
				return Math.min(powerProvider.getMaxEnergyReceived(), (int) (powerProvider.getMaxEnergyStored() - powerProvider.getEnergyStored() + 0.5f));
			}">powerRequest
			</replaceMethod>
		</class>
	</gregTech>
	<chickenChunks>
		<class id="codechicken.chunkloader.ChunkLoaderManager">
			<disable>cleanChunks</disable>
			<disable>tickEnd</disable>
			<newMethod code="
			public static void serverTick() {
        if (^class:MinecraftServer^.^method:MinecraftServer/getServer^().currentTick % 1200 == 0) {
        	updateLoginTimes();
        }
      	tickDownUnloads();
      	revivePlayerLoaders();
			}
			"/>
			<replaceMethodCall newMethod="getTEWithLoad" method="^class:World^.^method:World/getBlockTileEntity^">
				^all^
			</replaceMethodCall>
			<replaceMethodCall newMethod="getBlockIdWithLoad" method="^class:World^.^method:World/getBlockId^">^all^
			</replaceMethodCall>
		</class>
		<class id="codechicken.chunkloader.ChunkLoaderEventHandler">
			<replaceMethod
					code="return java.util.EnumSet.of(cpw.mods.fml.common.TickType.SERVER, cpw.mods.fml.common.TickType.WORLD);">
				ticks
			</replaceMethod>
			<replaceMethod code="{
			if($1.contains(cpw.mods.fml.common.TickType.SERVER)) {
			   codechicken.chunkloader.ChunkLoaderManager.serverTick();
         codechicken.chunkloader.PlayerChunkViewerManager.instance().update();
      }

      if($1.contains(cpw.mods.fml.common.TickType.WORLD)) {
         codechicken.chunkloader.PlayerChunkViewerManager.instance().calculateChunkChanges((^class:WorldServer^)$2[0]);
      }
			}">tickEnd
			</replaceMethod>
		</class>
		<class id="codechicken.chunkloader.PlayerChunkViewerManager">
			<replaceInitializer field="ticketIDs" class="nallar.collections.CHashMap"/>
			<replaceInitializer field="lastLoadedChunkMap" class="nallar.collections.CHashMap"/>
			<replaceInitializer field="playerViewers" class="nallar.collections.ConcurrentLinkedQueueList"/>
			<replaceInitializer field="chunkChanges" class="nallar.collections.LinkedListIterateClear"/>
			<replaceInitializer field="ticketChanges" class="nallar.collections.LinkedListIterateClear"/>
			<replaceInitializer field="dimChanges" class="nallar.collections.LinkedListIterateClear"/>
			<replaceInitializer field="logouts" class="nallar.collections.LinkedListIterateClear"/>
			<replaceInitializer field="addViewers" class="nallar.collections.LinkedListIterateClear"/>
			<replaceMethod code="{
				++time;
				nallar.collections.LinkedListIterateClear logouts = (nallar.collections.LinkedListIterateClear) this.logouts;
				Iterator var2 = logouts.clearIterator();
				ArrayList temp = new ArrayList(logouts.size() + 3);
				while (var2.hasNext()) {
					temp.add(var2.next());
				}

				var2 = temp.iterator();
				String username;
				while(var2.hasNext()) {
					username = (String)var2.next();
					Iterator player = playerViewers.iterator();

					while(player.hasNext()) {
						if(((codechicken.chunkloader.PlayerChunkViewerTracker)player.next()).owner.^field:EntityPlayer/username^.equals(username)) {
							player.remove();
						}
					}
				}

				var2 = temp.iterator();

				Iterator var4;
				codechicken.chunkloader.PlayerChunkViewerTracker player1;
				while(var2.hasNext()) {
					username = (String)var2.next();
					var4 = playerViewers.iterator();

					while(var4.hasNext()) {
						player1 = (codechicken.chunkloader.PlayerChunkViewerTracker)var4.next();
						player1.removePlayer(username);
					}
				}

				nallar.collections.LinkedListIterateClear dimChanges = (nallar.collections.LinkedListIterateClear) this.dimChanges;
				var2 = dimChanges.clearIterator();
				ArrayList tempDim = new ArrayList(dimChanges.size() + 3);
				while (var2.hasNext()) {
					tempDim.add(var2.next());
				}

				var2 = tempDim.iterator();
				codechicken.chunkloader.PlayerChunkViewerManager$DimensionChange username1;
				while(var2.hasNext()) {
					username1 = (codechicken.chunkloader.PlayerChunkViewerManager$DimensionChange)var2.next();
					if(username1.add) {
						var4 = playerViewers.iterator();

						while(var4.hasNext()) {
							player1 = (codechicken.chunkloader.PlayerChunkViewerTracker)var4.next();
							player1.loadDimension(username1.world);
						}
					}
				}

				nallar.collections.LinkedListIterateClear chunkChanges = (nallar.collections.LinkedListIterateClear) this.chunkChanges;

				var2 = chunkChanges.clearIterator();

				while(var2.hasNext()) {
					codechicken.chunkloader.PlayerChunkViewerManager$ChunkChange username2 = (codechicken.chunkloader.PlayerChunkViewerManager$ChunkChange)var2.next();
					var4 = playerViewers.iterator();

					while(var4.hasNext()) {
						player1 = (codechicken.chunkloader.PlayerChunkViewerTracker)var4.next();
						player1.sendChunkChange(username2);
					}
				}

				nallar.collections.LinkedListIterateClear ticketChanges = (nallar.collections.LinkedListIterateClear) this.ticketChanges;
				var2 = ticketChanges.clearIterator();

				while(var2.hasNext()) {
					codechicken.chunkloader.PlayerChunkViewerManager$TicketChange username3 = (codechicken.chunkloader.PlayerChunkViewerManager$TicketChange)var2.next();
					if(ticketIDs.containsKey(username3.ticket)) {
						var4 = playerViewers.iterator();

						while(var4.hasNext()) {
							player1 = (codechicken.chunkloader.PlayerChunkViewerTracker)var4.next();
							player1.sendTicketChange(username3);
						}
					} else {
						ticketIDs.put(username3.ticket, Integer.valueOf(ticketID++));
						var4 = playerViewers.iterator();

						while(var4.hasNext()) {
							player1 = (codechicken.chunkloader.PlayerChunkViewerTracker)var4.next();
							player1.addTicket(codechicken.core.CommonUtils.getDimension(username3.ticket.world), username3.ticket);
						}
					}
				}

				var2 = tempDim.iterator();

				while(var2.hasNext()) {
					username1 = (codechicken.chunkloader.PlayerChunkViewerManager$DimensionChange)var2.next();
					if(!username1.add) {
						var4 = playerViewers.iterator();

						while(var4.hasNext()) {
							player1 = (codechicken.chunkloader.PlayerChunkViewerTracker)var4.next();
							player1.unloadDimension(codechicken.core.CommonUtils.getDimension(username1.world));
						}
					}
				}

				if(time % 10 == 0) {
					var2 = codechicken.core.ServerUtils.getAllPlayers().iterator();

					while(var2.hasNext()) {
						^class:EntityPlayer^ username4 = (^class:EntityPlayer^)var2.next();
						var4 = playerViewers.iterator();

						while(var4.hasNext()) {
							player1 = (codechicken.chunkloader.PlayerChunkViewerTracker)var4.next();
							player1.updatePlayer(username4);
						}
					}
				}


				var2 = ((nallar.collections.LinkedListIterateClear) this.addViewers).clearIterator();

				while(var2.hasNext()) {
					username = (String)var2.next();
					^class:EntityPlayerMP^ player2 = codechicken.core.ServerUtils.getPlayer(username);
					if(player2 != null) {
						playerViewers.add(new codechicken.chunkloader.PlayerChunkViewerTracker(player2, this));
					}
				}
			 }">update
			</replaceMethod>
			<synchronize>update</synchronize>
			<synchronize field="$1.^field:WorldServer/theChunkProviderServer^.^field:ChunkProviderServer/loadedChunks^">
				calculateChunkChanges
			</synchronize>
		</class>
		<class id="codechicken.chunkloader.ChunkLoaderManager$ChunkLoaderOrganiser">
			<replaceMethodCall newMethod="getTEWithLoad" method="^class:World^.^method:World/getBlockTileEntity^">
				^all^
			</replaceMethodCall>
			<replaceMethodCall newMethod="getBlockIdWithLoad" method="^class:World^.^method:World/getBlockId^">^all^
			</replaceMethodCall>
			<synchronize>revive(L^class:World^;)V,devive,revive()V,load,save</synchronize>
			<replaceInitializer field="dormantLoaders" class="nallar.collections.CHashMap"/>
			<replaceInitializer field="forcedChunksByChunk" class="nallar.collections.CHashMap"/>
			<replaceInitializer field="forcedChunksByLoader" class="nallar.collections.CHashMap"/>
			<replaceInitializer field="timedUnloadQueue" class="nallar.collections.LinkedTimedHashMapQueue"/>
			<replaceMethod code="{
				Iterator iterator = this.timedUnloadQueue.keySet().iterator();
				while (iterator.hasNext()) {
					remChunk((codechicken.chunkloader.ChunkLoaderManager.DimChunkCoord)iterator.next());
				}
			}">tickDownUnloads
			</replaceMethod>
		</class>
		<class id="codechicken.core.CommonUtils">
			<replaceMethod code="return $1.dimensionId;">getDimension(L^class:World^;)I</replaceMethod>
		</class>
	</chickenChunks>
	<wirelessRedstone>
		<class id="codechicken.wirelessredstone.core.RedstoneEther">
			<replaceInitializer field="playerJammedMap" class="nallar.collections.CHashMap">init</replaceInitializer>
			<final field="playerJammedMap"/>
		</class>
		<class id="codechicken.wirelessredstone.core.RedstoneEtherServer">
			<synchronize>tick</synchronize>
		</class>
		<class id="codechicken.wirelessredstone.core.RedstoneEtherFrequency">
			<replaceMethodCall index="0" code="{}" method="println">updateReceiver</replaceMethodCall>
		</class>
	</wirelessRedstone>
	<extraBiomesXL>
		<class id="extrabiomes.blocks.BlockAutumnLeaves$BlockType">
			<insertBefore code="if (loadedCustomBlocks) { return; }">loadCustomBlocks</insertBefore>
			<synchronize/>
		</class>
		<class id="extrabiomes.blocks.BlockGreenLeaves$BlockType">
			<insertBefore code="if (loadedCustomBlocks) { return; }">loadCustomBlocks</insertBefore>
			<synchronize/>
		</class>
		<class id="extrabiomes.module.summa.worldgen.WorldGenLegendOak$TreeBlock">
			<insertBefore code="if (loadedCustomBlocks) { return; }">loadCustomBlocks</insertBefore>
			<synchronize>loadCustomBlocks</synchronize>
		</class>
		<class id="extrabiomes.module.summa.worldgen.WorldGenFirTreeHuge$TreeBlock">
			<insertBefore code="if (loadedCustomBlocks) { return; }">loadCustomBlocks</insertBefore>
			<synchronize>loadCustomBlocks</synchronize>
		</class>
		<class id="extrabiomes.module.summa.worldgen.WorldGenFirTree$TreeBlock">
			<insertBefore code="if (loadedCustomBlocks) { return; }">loadCustomBlocks</insertBefore>
			<synchronize>loadCustomBlocks</synchronize>
		</class>
		<class id="extrabiomes.module.summa.worldgen.WorldGenAutumnTree$AutumnTreeType">
			<insertBefore code="if (loadedCustomBlocks) { return; }">loadCustomBlocks</insertBefore>
			<synchronize>loadCustomBlocks</synchronize>
		</class>
		<class id="extrabiomes.module.summa.worldgen.WorldGenAcacia$TreeBlock">
			<insertBefore code="if (loadedCustomBlocks) { return; }">loadCustomBlocks</insertBefore>
			<synchronize>loadCustomBlocks</synchronize>
		</class>
		<class id="extrabiomes.module.summa.worldgen.WorldGenRedwood$TreeBlock">
			<insertBefore code="if (loadedCustomBlocks) { return; }">loadCustomBlocks</insertBefore>
			<synchronize>loadCustomBlocks</synchronize>
		</class>
	</extraBiomesXL>
	<portalGun>
		<class id="portalgun.common.core.PacketHandlerServer">
			<replaceMethodCall method="console" index="0" code="{ }">onPacketData</replaceMethodCall>
		</class>
		<class id="portalgun.common.core.TickHandlerServer">
			<synchronize field="$1.^field:World/loadedEntityList^">worldTick</synchronize>
			<replaceInitializer field="grabMap" class="nallar.collections.CHashMap"/>
			<replaceInitializer field="portals" class="nallar.collections.CHashMap"/>
			<replaceInitializer field="moonPortals" class="nallar.collections.CHashMap"/>
			<replaceInitializer field="potatosProgression" class="nallar.collections.CHashMap"/>
			<replaceInitializer field="lastSeenEntity" class="nallar.collections.CHashMap"/>
			<replaceInitializer field="hasFallen" class="nallar.collections.CHashMap"/>
		</class>
		<class id="portalgun.common.core.ChunkLoadHandler">
			<replaceInitializer field="entTickets" class="nallar.collections.CHashMap"/>
			<replaceInitializer field="portalTickets" class="nallar.collections.CHashMap"/>
			<replaceMethodCall newMethod="getTEWithLoad" method="^class:World^.^method:World/getBlockTileEntity^">
				ticketsLoaded(Ljava.util.List;L^class:World^;)V,ticketsLoaded(Ljava.util.List;L^class:World^;I)Ljava.util.List;
			</replaceMethodCall>
			<replaceMethodCall newMethod="getBlockIdWithLoad" method="^class:World^.^method:World/getBlockId^">
				ticketsLoaded(Ljava.util.List;L^class:World^;)V,ticketsLoaded(Ljava.util.List;L^class:World^;I)Ljava.util.List;
			</replaceMethodCall>
			<synchronize static=""/>
		</class>
	</portalGun>
	<graviGun>
		<class id="gravigun.common.core.TickHandlerServer">
			<synchronize field="$1.^field:World/weatherEffects^">worldTick</synchronize>
			<replaceInitializer field="grabMap" class="java.util.concurrent.ConcurrentHashMap"/>
			<replaceInitializer field="tossedEntities" class="java.util.concurrent.ConcurrentHashMap"/>
			<replaceInitializer field="tosser" class="java.util.concurrent.ConcurrentHashMap"/>
			<replaceInitializer field="chargedThrow" class="java.util.concurrent.ConcurrentHashMap"/>
		</class>
	</graviGun>
	<twilightForest>
		<class id="twilightforest.entity.HydraHeadContainer">
			<insertBefore code="{
				if ($1 != null &amp;&amp; $1.^field:Entity/boundingBox^ == null) {
					return;
				}
			}">faceEntity,setTargetEntity
			</insertBefore>
		</class>
		<class id="twilightforest.TFFeatureCache">
			<replaceInitializer field="cache" class="nallar.collections.SynchronizedList"/>
			<synchronize field="cache">save</synchronize>
			<insertAfter code="{
				if (!(cache instanceof nallar.collections.SynchronizedList)) {
					cache = new nallar.collections.SynchronizedList(cache);
				}
			}">load
			</insertAfter>
		</class>
		<class id="twilightforest.block.BlockTFMagicLogSpecial">
			<!-- Spams logs, slow -->
			<disable>doSortingTreeEffect</disable>
		</class>
		<class id="twilightforest.biomes.TFBiomeDecorator">
			<synchronize>^method:BiomeDecorator/decorate^</synchronize>
		</class>
	</twilightForest>
	<additionalPipes>
		<class id="buildcraft.additionalpipes.pipes.PipePowerTeleport">
			<synchronize>receiveEnergy,requestEnergy</synchronize>
		</class>
		<class id="buildcraft.additionalpipes.pipes.TeleportManager">
			<synchronize>getConnectedPipes</synchronize>
		</class>
	</additionalPipes>
	<thaumcraft>
		<class id="thaumcraft.common.lib.WorldTicker">
			<newField code="nallar.tickthreading.util.contextaccess.ContextAccess.$"
					  class="nallar.tickthreading.util.contextaccess.ContextAccess" field="context" static="true"/>
			<insertBefore code="{
				if (context.runningUnder(thaumcraft.common.lib.WorldTicker.class)) {
					return;
				}
			}">addSwapper
			</insertBefore>
		</class>
		<class id="thaumcraft.common.tiles.TileSensor">
			<replaceMethod code="((ArrayList) noteBlockEvents.get($1)).addAll($1.getNoteBlockEvents());">
				getNoteBlockEvents
			</replaceMethod>
		</class>
	</thaumcraft>
	<appliedEnergistics>
		<class id="appeng.me.crafting.CraftRequest">
			<replaceInitializer field="Prereqs" class="nallar.collections.SynchronizedList"/>
			<final field="Prereqs"/>
		</class>
		<class id="appeng.me.CellInventory">
			<synchronize>^all^</synchronize>
		</class>
		<class id="appeng.me.MEInventoryNetwork">
			<newField class="nallar.tickthreading.util.LinkedListThreadLocal" field="depthsThreadLocal"/>
			<!-- I know that's not how you spell recursion, typos kept from AE :P -->
			<replaceMethod code="{
				Object grid = $1.getGrid();
				LinkedList depths = (LinkedList) depthsThreadLocal.get();
				for (Iterator i$ = depths.iterator(); i$.hasNext(); ) {
					if (grid == i$.next()) {
						return false;
					}
				}
				depths.push(grid);
				return true;
			}">checkRecurrsion</replaceMethod>
			<replaceMethod code="{
				Object grid = $1.getGrid();
				if ($1.getGrid() != ((LinkedList) depthsThreadLocal.get()).pop()) {
					throw new RuntimeException(&quot;Invalid Network Recussion Detected&quot;);
				}
			}">endRecurssion</replaceMethod>
		</class>
		<class id="appeng.util.Platform">
			<insertBefore code="{
				if ($1 == $2) {
					return true;
				}
				if ($1 == null || $2 == null) {
					return false;
				}
			}">NBTEqualityTest
			</insertBefore>
		</class>
		<class id="appeng.api.me.tiles.IGridMachine">
			<newMethod code="public abstract void tickNetwork();"/>
		</class>
		<class id="appeng.me.tile.TileController">
			<newField class="int" static="" field="tickSkip" code="0"/>
			<newField class="java.util.ArrayList" code="new ArrayList();" field="tiles"/>
			<synchronize field="$1">requestUpdate</synchronize>
			<rename name="requestUpdate_">requestUpdate</rename>
			<newField field="updateQueue" class="java.util.concurrent.ConcurrentLinkedQueue"
					  code="new java.util.concurrent.ConcurrentLinkedQueue()"/>
			<newMethod code="public void requestUpdate(appeng.api.me.tiles.IGridTileEntity tt) {
				if (tt instanceof appeng.me.tile.TileInterfaceBase) {
					updateQueue.add(tt);
				}
			}"/>
			<insertBefore code="{
				appeng.api.me.tiles.IGridTileEntity tt;
				HashSet done = new HashSet();
				while ((tt = ((appeng.api.me.tiles.IGridTileEntity) updateQueue.poll())) != null) {
					if (done.add(tt)) {
						requestUpdate_(tt);
					}
				}
				if (enabled) {
					Iterator i = tiles.iterator();
					while (i.hasNext()) {
						appeng.api.me.tiles.IGridMachine igm = (appeng.api.me.tiles.IGridMachine) i.next();
						try {
							igm.tickNetwork();
						} catch (AbstractMethodError e) {
							System.out.println(&quot;AE IGridMachine missing tickNetwork: &quot; + igm.getClass().getName());
						}
					}
				}
				if (tickSkip++ % 2 == 0) {
					return;
				}
			}">updateTileEntity
			</insertBefore>
			<insertBefore code="{
				tiles.clear();
				if ($1 != null) {
					Iterator i = $1.iterator();
					while (i.hasNext()) {
						appeng.common.grid.GridEnumeration$NetworkNode tr = (appeng.common.grid.GridEnumeration$NetworkNode) i.next();
						^class:TileEntity^ tile = (^class:TileEntity^) tr.getTile();
						if (tile != this &amp;&amp; tile != null &amp;&amp; tile instanceof appeng.api.me.tiles.IGridMachine) {
							tiles.add(tile);
						}
					}
				}
			}">configureController
			</insertBefore>
			<replaceInitializer field="WaitingQueue" class="nallar.collections.ConcurrentLinkedQueueList"/>
			<replaceInitializer field="CraftingQueue" class="nallar.collections.ConcurrentLinkedQueueList"/>
			<synchronize field="CManager.getPrereqs()">getJobList,getJobStatus,cancelJob</synchronize>
			<synchronize>
				configureController,getCellArray,updateTileEntity,advanceCraftingCursor,resetWaitingQueue
			</synchronize>
		</class>
		<class id="appeng.me.tile.TileStorageBus">
			<synchronize>getCellArray,getItem</synchronize>
		</class>
		<class id="appeng.me.MEInventoryArray">
			<synchronize>^all^</synchronize>
		</class>
		<class id="appeng.common.grid.MEGridEvents">
			<replaceInitializer field="requests" class="nallar.collections.ConcurrentQueueList">^static^</replaceInitializer>
			<replaceInitializer field="mbupdates" class="nallar.collections.ConcurrentQueueList">^static^</replaceInitializer>
		</class>
		<class id="
			appeng.me.tile.TileAssembler
			appeng.me.tile.TileAssemblerMB
			appeng.me.tile.TileChest
			appeng.me.tile.TileCraftingMonitor
			appeng.me.tile.TileDarkCable
			appeng.me.tile.TileDrive
			appeng.me.tile.TileEnergyCell
			appeng.me.tile.TileInputCable
			appeng.me.tile.TileInterfaceBase
			appeng.me.tile.TileIOPort
			appeng.me.tile.TileLevelEmitter
			appeng.me.tile.TileOutputCable
			appeng.me.tile.TileP2PTunnel
			appeng.me.tile.TileSpatialIOPort
			appeng.me.tile.TileSpatialPylon
			appeng.me.tile.TileStorageBus
			appeng.me.tile.TileStorageMonitor
			appeng.me.tile.TileTerminal
			appeng.me.tile.TileTransitionPlane
			appeng.me.tile.TileWireless
			crazypants.enderio.conduit.TileConduitBundle
			extracells.tileentity.TileEntityBusFluidExport
			extracells.tileentity.TileEntityBusFluidImport
			extracells.tileentity.TileEntityBusFluidStorage
			extracells.tileentity.TileEntityFluidCrafter
			extracells.tileentity.TileEntityHardMEDrive
			extracells.tileentity.TileEntityInterfaceFluid
			extracells.tileentity.TileEntityLevelEmitterFluid
			extracells.tileentity.TileEntityMEDropper
			extracells.tileentity.TileEntityMonitorStorageFluid
			extracells.tileentity.TileEntityTerminalFluid
			extracells.tileentity.TileEntityTransitionPlaneFluid
		">
			<newMethod code="public void updateTileEntity() { }" ignoreDuplicate=""/>
			<renameInterfaceMethod name="tickNetwork" interface="appeng.api.me.tiles.IGridMachine" allowMissing="">
				updateTileEntity
			</renameInterfaceMethod>
			<newMethod code="private Object getNetworkLock() {
				Object o = getGrid();
				if (o instanceof appeng.api.TileRef) {
					o = ((appeng.api.TileRef) o).getTile();
				}
				return o == null ? new Object() : o;
			}"/>
		</class>
		<class id="appeng.me.tile.TileDrive">
			<synchronize field="getNetworkLock()">getCellArray,resetCache</synchronize>
		</class>
		<class id="appeng.me.tile.TileChest">
			<synchronize field="getNetworkLock()">getCellArray,resetCache</synchronize>
		</class>
	</appliedEnergistics>
	<enderIo>
		<class id="crazypants.enderio.conduit.AbstractConduitNetwork">
			<newField field="staticLock" class="java.lang.Object" static=""/>
			<synchronize field="staticLock">init</synchronize>
		</class>
		<class id="crazypants.enderio.conduit.ConduitNetworkTickHandler">
			<replaceInitializer field="listeners" class="nallar.collections.SynchronizedList"/>
			<synchronize field="listeners">tickStart,tickEnd</synchronize>
			<insertBefore code="{ if ($1 == null) { throw new NullPointerException(); } }">addListener</insertBefore>
		</class>
	</enderIo>
	<denLib>
		<class id="denoflionsx.denLib.Mod.Handlers.ChunkHandler">
			<removeMethod>onEvent</removeMethod>
		</class>
	</denLib>
	<icbm>
		<class id="icbm.api.RadarRegistry">
			<replaceMethod code="detectableEntities.remove($1);">unregister(L^class:Entity^;)V</replaceMethod>
			<replaceMethod code="detectableTileEntities.remove($1);">unregister(L^class:TileEntity^;)V</replaceMethod>
			<replaceMethodCall code="$_ = $0.getTEWithoutLoad($$);"
							   method="^class:World^.^method:World/getBlockTileEntity^">cleanUpArray
			</replaceMethodCall>
			<synchronize>
				cleanUpArray,getEntitiesWithinRadius,getTileEntitiesInArea,unregister(L^class:Entity^;)V,unregister(L^class:TileEntity^;)V,register(L^class:Entity^;)V,register(L^class:TileEntity^;)V
			</synchronize>
			<insertBefore
					code="if (!Thread.holdsLock(icbm.api.RadarRegistry.class)) { throw new UnsupportedOperationException(&quot;Not threadsafe.&quot;); }">
				getEntities,getTileEntities
			</insertBefore>
		</class>
	</icbm>
	<forestry>
		<class id="forestry.apiculture.gadgets.TileAlvearyPlain">
			<replaceInitializer field="modifiers"
								code="$_ = java.util.Collections.newSetFromMap(new java.util.concurrent.ConcurrentHashMap());"/>
			<replaceInitializer field="eventHandlers"
								code="$_ = java.util.Collections.newSetFromMap(new java.util.concurrent.ConcurrentHashMap());"/>
		</class>
	</forestry>
	<railCraft>
		<class id="railcraft.common.util.misc.ChunkManager">
			<replaceMethodCall newMethod="getTEWithLoad" method="^class:World^.^method:World/getBlockTileEntity^">
				ticketsLoaded(Ljava.util.List;L^class:World^;)V,ticketsLoaded(Ljava.util.List;L^class:World^;I)Ljava.util.List;
			</replaceMethodCall>
			<replaceMethodCall newMethod="getBlockIdWithLoad" method="^class:World^.^method:World/getBlockId^">
				ticketsLoaded(Ljava.util.List;L^class:World^;)V,ticketsLoaded(Ljava.util.List;L^class:World^;I)Ljava.util.List;
			</replaceMethodCall>
		</class>
	</railCraft>
	<seasons>
		<class id="WeatherPony.Seasons.Seasons_WorldData">
			<insertAfter code="worldsettings = new java.util.concurrent.ConcurrentHashMap();"/>
		</class>
	</seasons>
	<customOreGen>
		<class id="CustomOreGen.Server.ServerState">
			<replaceMethod code="{ return $1.isChunkSavedPopulated($2, $3); }">isChunkSavedPopulated</replaceMethod>
		</class>
	</customOreGen>
	<enderStorage>
		<class id="codechicken.enderstorage.api.EnderStorageManager">
			<insertAfter code="dirtyStorage = new nallar.collections.LinkedListReplaceIterateTempListClear();"/>
		</class>
	</enderStorage>
	<millenaire>
		<class id="org.millenaire.common.forge.Mill">
			<replaceInitializer field="serverWorlds" class="nallar.collections.CopyOnWriteVector"/>
		</class>
		<class id="org.millenaire.common.MillVillager">
			<replaceMethodCall method="error" code="{ }">registerInGlobalList</replaceMethodCall>
		</class>
		<class id="org.millenaire.common.MillWorld">
			<replaceMethod code="{ return (org.millenaire.common.Building) this.buildings.get($1);	}">getBuilding
			</replaceMethod>
		</class>
		<class id="org.millenaire.common.Point">
			<replaceMethod code="{
				return ((int) x) | (((int) y) &lt;&lt; 12) | (((int) z) &lt;&lt; 20);
			}">hashCode
			</replaceMethod>
		</class>
	</millenaire>
	<stevesCarts>
		<class id="vswe.stevescarts.CommonProxy">
			<replaceMethod code="{
				^class:Entity^ entity = $2.getEntity($1);
				if (entity instanceof vswe.stevescarts.Carts.MinecartModular) {
					return (vswe.stevescarts.Carts.MinecartModular) entity;
				}
				return null;
			}">getCart
			</replaceMethod>
		</class>
	</stevesCarts>
	<dynmap>
		<class id="org.dynmap.forge.SnapshotCache">
			<synchronize/>
		</class>
		<class id="org.dynmap.forge.ForgeMapChunkCache">
			<replaceMethod code="return this.cps.getChunkAt($1, $2, false, null);">loadChunkNoGenerate</replaceMethod>
			<replaceMethod code="return this.cps.readChunkNBT($1, $2);">readChunk</replaceMethod>
		</class>
	</dynmap>
	<gregsLighting>
		<class id="gcewing.lighting.Floodlight">
			<synchronize static="true"/>
		</class>
	</gregsLighting>
	<hats>
		<class id="hats.common.core.TickHandlerServer">
			<replaceInitializer field="mobHats" class="nallar.collections.ConcurrentWeakHashMap"/>
		</class>
	</hats>
	<xReliquary>
		<class id="xeno.reliquary.items.AlkahestHandler">
			<replaceMethodCall code="{}" method="println">onCrafting</replaceMethodCall>
		</class>
	</xReliquary>
	<tubestuff>
		<class id="immibis.tubestuff.TubeStuff">
			<insertBefore code="{
				if ($1 == $2) {
					return true;
				}
				if ($1 == null || $2 == null) {
					return false;
				}
			}">areItemsEqual
			</insertBefore>
		</class>
	</tubestuff>
	<mekanism>
		<class id="mekanism.common.TileEntitySmeltingFactory">
			<ignoreExceptions type="java.lang.NullPointerException">onUpdate</ignoreExceptions>
		</class>
	</mekanism>
	<magicBees>
		<class id="magicbees.world.WorldTicker">
			<replaceNew oldClass="java.util.LinkedList" newClass="nallar.collections.ConcurrentLinkedQueueList">
				queueChunkCoords
			</replaceNew>
		</class>
	</magicBees>
	<tagApi>
		<class id="org.kitteh.tag.TagAPI">
			<!-- Allow TagAPI use off the main thread -->
			<replaceMethodCall method="equals" code="$_ = true;" index="0">check,getName</replaceMethodCall>
		</class>
	</tagApi>
	<mobHats>
		<class id="hats.common.core.TickHandlerServer">
			<newField field="skip" class="int" code="0"/>
			<insertBefore code="{
				if (skip++ % 1800 != 0) {
				 return;
				}
			}">worldTick
			</insertBefore>
			<replaceMethodCall method="^class:EntityLiving^.^method:Entity/isEntityAlive^"
							   code="$_ = $0.^method:Entity/isEntityAlive^() &amp;&amp; $0.chunk != null;">worldTick
			</replaceMethodCall>
		</class>
	</mobHats>
	<revamp>
		<class id="rivvest.Revamp.EntityEventHandler">
			<replaceInitializer field="entitiesToConvert" class="nallar.collections.SynchronizedList"/>
			<replaceMethod code="{
				^class:World^ world = $1.world;
				if (!world.^field:World/isRemote^ &amp;&amp; world.getDimension() == 0) {
					rivvest.Revamp.Revamp.instance.setCaveVillageCollection(new rivvest.Revamp.CaveVillageCollection(world));
     				rivvest.Revamp.Revamp.instance.setWorldObj(world);
				}
			}">onWorldLoad</replaceMethod>
		</class>
		<class id="rivvest.Revamp.ServerTickerRevamp">
			<replaceMethodCall method="java.util.List.clear" code="{}">runConversions</replaceMethodCall>
			<insertBefore code="{
				synchronized ($1) {
					ArrayList temp = new ArrayList($1);
					$1.clear();
					$1 = temp;
				}
			}">runConversions
			</insertBefore>
		</class>
	</revamp>
	<morpheus>
		<class id="net.quetzi.morpheus.SleepChecker">
			<replaceMethod code="{
				if (($1 != null) &amp;&amp; (net.quetzi.morpheus.Morpheus.alertEnabled)) {
					for (Iterator i$ = $2.^field:World/playerEntities^.iterator(); i$.hasNext(); ) {
						^class:EntityPlayerMP^ entityPlayer = (^class:EntityPlayerMP^)i$.next();
						entityPlayer.^method:EntityPlayerMP/sendChatToPlayer^($1);
					}
				}
				net.quetzi.morpheus.Morpheus.mLog.info($1.toString());
			}">alertPlayers
			</replaceMethod>
			<replaceMethod code="{
					for (Iterator i$ = $1.^field:World/playerEntities^.iterator(); i$.hasNext(); ) {
						^class:EntityPlayerMP^ player = (^class:EntityPlayerMP^)i$.next();
						net.quetzi.morpheus.world.WorldSleepState wss = (net.quetzi.morpheus.world.WorldSleepState) net.quetzi.morpheus.Morpheus.playerSleepStatus.get(Integer.valueOf(player.^field:Entity/dimension^));
						if (player.^method:EntityPlayer/isPlayerFullyAsleep^() &amp;&amp; !wss.isPlayerSleeping(player.^field:EntityPlayerMP/username^)) {
							wss.setPlayerAsleep(player.^field:EntityPlayerMP/username^);
							alertPlayers(createAlert(player.^field:Entity/worldObj^, player,net.quetzi.morpheus.Morpheus.onSleepText), $1);
						} else if (!player.^method:EntityPlayer/isPlayerFullyAsleep^() &amp;&amp; wss.isPlayerSleeping(player.^field:EntityPlayerMP/username^)) {
							wss.setPlayerAwake(player.^field:EntityPlayerMP/username^);
							alertPlayers(createAlert(player.^field:Entity/worldObj^, player,net.quetzi.morpheus.Morpheus.onWakeText), $1);
						}
					}
			}">updatePlayerStates
			</replaceMethod>
		</class>
	</morpheus>
	<hee>
		<!-- TODO - Fix HEE possibly reloading this data WAY too regularly? -->
		<class id="chylex.hee.system.savedata.Savefile">
			<newField field="staticLock" class="java.lang.Object" static=""/>
			<synchronize field="staticLock">save,load</synchronize>
		</class>
	</hee>
	<canUpdateFixes onDemand="true">
		<class id="
		com.advGenetics.TileEntity.TileEntityMicroscope
		com.xcompwiz.mystcraft.tileentity.TileEntityBookBinder
		com.xcompwiz.mystcraft.tileentity.TileEntityBookReceptacle
		com.xcompwiz.mystcraft.tileentity.TileEntityBookstand
		com.xcompwiz.mystcraft.tileentity.TileEntityLinkModifier
		com.xcompwiz.mystcraft.tileentity.TileEntityStarFissure
		emasher.sockets.pipes.TileDirectionChanger
		emasher.sockets.pipes.TileFrame
		extracells.tileentity.TileEntityCertusTank
		extracells.tileentity.TileEntityHardMEDrive
		extracells.tileentity.TileEntityLevelEmitterFluid
		extracells.tileentity.TileEntityMEDropper
		extracells.tileentity.TileEntityMonitorStorageFluid
		extracells.tileentity.TileEntityVoidFluid
		extrautils.tileentity.TileEntityAntiMobTorch
		extrautils.tileentity.TileEntityPortal
		factorization.shared.TileEntityFzNull
		logisticspipes.blocks.LogisticsSecurityTileEntity
		logisticspipes.blocks.crafting.LogisticsCraftingTableTileEntity
		lumien.randomthings.TileEntities.TileEntityFluidDisplay
		net.machinemuse.powersuits.block.TileEntityTinkerTable
		org.yogpstop.qp.TileBreaker
		org.yogpstop.qp.TilePlacer
		tconstruct.blocks.logic.CraftingStationLogic
		tconstruct.blocks.logic.PartBuilderLogic
		thaumcraft.common.tiles.TileGrate
		tmechworks.blocks.logic.DynamoLogic
		vazkii.heraldry.content.TileEntityBanner
		vazkii.tinkerer.common.block.tile.TileAspectAnalyzer
		vswe.stevescarts.TileEntities.TileEntityActivator
		">
			<newMethod code="public boolean ^method:TileEntity/canUpdate^() {
				return false;
			}"/>
		</class>
	</canUpdateFixes>
	<Reika>
		<class id="com.xcompwiz.mystcraft.world.AgeController">
			<synchronize>getInstabilityController</synchronize>
			<public>getInstabilityController</public>
		</class>
		<class id="Reika.DragonAPI.ModInteract.ReikaMystcraftHelper$InstabilityInterface">
			<insertAfter code="{
				if (instabilityController == null) {
					instabilityController = ((com.xcompwiz.mystcraft.world.AgeController) ageController).getInstabilityController();
				}
				if (ageController == null || instabilityController == null || ageData == null) {
					throw new IllegalArgumentException(&quot;Null mystcraft age info: &quot; + String.valueOf(ageController) + &quot;, &quot; + String.valueOf(instabilityController) + &quot;, &quot; + String.valueOf(ageData));
				}
			}"/>
		</class>
	</Reika>
	<minions>
		<class id="
		atomicstryker.minions.common.jobmanager.Minion_Job_DigByCoordinates
		atomicstryker.minions.common.jobmanager.Minion_Job_DigMineStairwell
		atomicstryker.minions.common.jobmanager.Minion_Job_Manager
		atomicstryker.minions.common.jobmanager.Minion_Job_StripMine
		atomicstryker.minions.common.jobmanager.Minion_Job_TreeHarvest
		">
			<synchronize allowMissing="true">getAnyAvailableWorker,getNearestAvailableWorker,onJobFinished,onJobStarted,onJobUpdateTick,onTaskFinished,setWorkerFree</synchronize>
		</class>
	</minions>
	<opis>
		<class id="mcp.mobius.opis.data.managers.StringCache">
			<replaceMethod code="{
				Integer inv = ((Integer)this.cache.inverse().get($1)).intValue();
				if (inv != null) {
				  return inv.intValue();
				}
				synchronized(this) {
					this.currentIndex += 1;
					this.cache.put(Integer.valueOf(this.currentIndex), $1);
					mcp.mobius.opis.data.holders.newtypes.DataStringUpdate upd = new mcp.mobius.opis.data.holders.newtypes.DataStringUpdate($1, this.currentIndex);
					this.toSend.add(upd);
					cpw.mods.fml.common.network.PacketDispatcher.sendPacketToAllPlayers(NetDataValue.create(mcp.mobius.opis.network.enums.Message.STATUS_STRINGUPD, upd).packet);
					return this.currentIndex;
				}
			}">getIndex</replaceMethod>
			<synchronize>syncCache</synchronize>
		</class>
	</opis>
	<pixelMon>
		<class id="pixelmon.spawning.PixelmonSpawner">
			<synchronize>tickEnd</synchronize>
		</class>
	</pixelMon>
	<meteorCraft>
		<!-- WHO NEEDS NAMING CONVENTIONS ANYWAY? Thanks Reika! -->
		<class id="Reika.MeteorCraft.OldMeteorGenerator">
			<replaceMethod code="{
				^class:World^ world = $1;
				int x = $2;
				int z = $3;
				if (world.dimensionId == Reika.DragonAPI.ModInteract.ReikaTwilightHelper.getDimensionID()) {
				  return 5 + rand.nextInt(30);
				}
				^class:BiomeGenBase^ biome = world.func_72807_a(x, z);
				int max = (int)(biome.field_76749_E * world.field_73011_w.func_76557_i());
				if (max &lt; 2) {
					return 5;
				}
				int tries = 0;
				int y = 5 + rand.nextInt(max);
				while (world.func_72937_j(x, y + 1, z)) {
					if (tries++ > 10) {
						return 5 + max - 1;
					}
					y = 5 + rand.nextInt(max);
				}
				return y;
			}">getGenY</replaceMethod>
		</class>
	</meteorCraft>
	<galacticraft>
		<class id="micdoodle8.mods.galacticraft.core.tick.GCCoreTickHandlerServer">
			<!-- Lazy fix - synchronize all methods in this class rather than trying to use concurrent collections
			Could have fixed in a way that doesn't add so much synchronization overhead but can't be bothered :D
			-->
			<synchronize/>
		</class>
	</galacticraft>
</mods>
